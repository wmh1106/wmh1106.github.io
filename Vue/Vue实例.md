# Vue 实例：

所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象（option）

Vue实例暴露出来的属性和方法名字前都带有$

## 全局的构造函数

`new Vue(option)`

## 选项对象 `option`

### 1. el：告诉Vue管理的模板范围

### 2. 数据：data【会被实例代理，转成getter/setter形式】

- 模板、视图
- 数据添加到模板中
- 把数据与模板进行关联：模板语法（插值表达式）
- 插值表达式：
	1. 使用双大括号（“Mustache”语法）做文本插值
	2. 可以写任意表达式
	3. 属性名、条件运算符、数据方法调用


**`注意`**：响应式的数据，必须是在初始化vue 实例的时候，就存在于 data 属性里。所以如果预知后面会用到的变量，可以先设置初始值

### 3. 方法：methods:

vue 代理 data 数据是响应的，新添加的属性不具备响应功能，改变后不会更新视图

vue 实例自身属性和方法：vm.$el、vm.$data

定义在`methods`里的方法，将被混入到`Vue`实例中。如：`var vm = new Vue(...)`

1. 可以直接通过`vm`实例访问这些方法，
2. 可以在指令表达式中使用
3. 方法中的`this`自动绑定为`Vue`实例

## 4. 计算属性：computed

- 需求：数据过滤
	- 对原始数据（data属性中），进行加工处理，生成自己需要的派生数据（computed属性中）。把对处理数据的逻辑抽离在计算属性中，使得模板更加轻量易读
- 计算属性的使用
	1. 可以像绑定普通属性一样在模板中绑定计算属性
	2. 取值:触发get函数，默认设置的函数
	3. 赋值:触发set函数
	4. 在`computed`属性中，定义的“函数”，但是使用的时候，**`要把它当做属性来用`**
- 特性：
	1. 可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。
	2. 计算属性的值会被缓存，并根据依赖的数据变化而重新计算,且可在模板中重复使用
	3. 计算属性挂载实例上
	4. 计算属性对应的函数this都指向实例
	5. 计算属性中依赖了data中的数据，data中的数据发生变化，计算属性会重新计算
- 对象形式：set()、get()
	
## 5. 观察：watch

- 需求：监听 **`已有数据`** 变化
	- 利用`watch`观察`Vue实例`上的`数据(data)`变动，`键(key)`是需要`观察的表达式`，`值(value)`是对应`回调函数`
	- 默认只监听当前数据的变化，不监听子级数据
- watch 深度监控
	- `handler(){}`：可以在里面写任意的异步操作
	- deep:true
- **`最佳使用场景`**：当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的
回调函数：newValue（变化的最新值）、oldValue（变化之前的值）

```javascript
// watch 深度监控
watch: {
	tasks: {
		deep: true,
		handler() {
			console.log(1)
		}
	}
}
```





