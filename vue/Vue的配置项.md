# Vue 构造函数

所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象（option）

Vue 实例暴露出来的属性和方法名字前都带有$

## 全局的构造函数

`new Vue(option)`

## 选项对象 `option`

### 1. el：告诉 Vue 管理的模板范围

### 2. 数据：data【会被实例代理，转成 getter/setter 形式】

* 模板、视图
* 数据添加到模板中
* 把数据与模板进行关联：模板语法（插值表达式）
* 插值表达式：
  * 使用双大括号（“Mustache”语法）做文本插值
  * 可以写任意表达式
  * 属性名、条件运算符、数据方法调用

**`注意`**：响应式的数据，必须是在初始化 vue 实例的时候，就存在于 data 属性里。所以如果预知后面会用到的变量，可以先设置初始值

### 3. 方法：methods

vue 代理 data 数据是响应的，新添加的属性不具备响应功能，改变后不会更新视图

vue 实例自身属性和方法：vm.$el、vm.$data

定义在`methods`里的方法，将被混入到`Vue`实例中。如：`var vm = new Vue(...)`

* 可以直接通过`vm`实例访问这些方法，
* 可以在指令表达式中使用
* 方法中的`this`自动绑定为`Vue`实例

## 4. 计算属性：computed

* 需求：数据过滤 - 对原始数据（data 属性中），进行加工处理， 生成自己需要的派生数据（computed 属性中）。把对处理数据的逻辑抽离在计算属性中，使得模板更加轻量易读
* 计算属性的使用 1. 可以像绑定普通属性一样在模板中绑定计算属性 2. 取值:触发 get 函数，默认设置的函数 3. 赋值:触发 set 函数 4. 在`computed`属性中，定义的“函数”，但是使用的时候，**`要把它当做属性来用`**
* 特性： 1. 可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。 2. 计算属性的值会被缓存，并根据依赖的数据变化而重新计算,且可在模板中重复使用 3. 计算属性挂载实例上 4. 计算属性对应的函数 this 都指向实例 5. 计算属性中依赖了 data 中的数据，data 中的数据发生变化，计算属性会重新计算
* 对象形式：set()、get()

## 5. 观察：watch

* 需求：监听 **`已有数据`** 变化 - 利用`watch`观察`Vue实例`上的`数据(data)`变动，`键(key)`是需要`观察的表达式`，`值(value)`是对应`回调函数` - 默认只监听当前数据的变化，不监听子级数据
* watch 深度监控 - `handler(){}`：可以在里面写任意的异步操作 - deep:true
* **`最佳使用场景`**：当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的回调函数：newValue（变化的最新值）、oldValue（变化之前的值）

```js
// watch 深度监控

watch: {
  tasks: {
    deep: true,
      handler() {
      console.log(1)
    }
  }
}
```
